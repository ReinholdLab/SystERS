#' @title UpdateCells
#'
#' @description Update water and solute values in each cell.
#'
#' @param cells A list of cells in the model.
#' @param storesList A list of stores values generated by \code{CalcStores$new()}.
#'
#' @return A list of cells with updated water and solute values.
#'

UpdateCells <-
  R6::R6Class(
    classname = "UpdateCells",
    public =
      list(
        # storesList = NULL,
        cells = NULL,
        initialize =
          function(cells){
          # function(cells, storesList){


            for(cellIdx in row.names(storesList[["H2O"]]) ){
              cellToUpdate <- cells[[which(sapply(cells, function(c) c$cellIdx) == cellIdx)]]

              # cellToUpdate$channelVolume_L <- storesList[["H2O"]][cellIdx,"endVal"]
              cellToUpdate$channelVolume_m3 <- cellToUpdate$channelVolume_L / 1000
              cellToUpdate$channelDepth <- cellToUpdate$channelVolume_m3 / cellToUpdate$channelArea # assumes channel is a rectangular cuboid with fixed W and L

              #### Need to figure out how we want to calculate discharge so that
              #### we can update mean water velocity, channel residence time,
              #### and hydraulic load ###

              # cellToUpdate$soluteMass <- storesList[["NO3"]][cellIdx, "endVal"]
              cellToUpdate$soluteConcentration <- cellToUpdate$soluteMass / cellToUpdate$channelVolume_L
            }
            return()
          }
      )

  )

#' @title UpdateBounds
#'
#' @description Update boundaries based on trades.
#'
#' @param tradeDf A dataframe of trades.  This is generated by the WQModel$trade
#'   method; currently, it is the first object returned in the list.
#' @param boundsList A list containing all the boundaries in the model.
#' @param timeInterval The duration of the time step.
#'
#' @return A list of boundaries with updated values.
#'

UpdateBounds <-
  R6::R6Class(
    classname = "UpdateBounds",
    public =
      list(
        cells = NULL,
        initialize = function(tradeDf, boundsList, timeInterval){
          # this first bit overwrites the passed bounds list after extracting
          # only the boundaries to be updated and ordering them according to the
          # order in the trade df
          boundsList <- apply(as.data.frame(tradeDf$boundIdx), 1, function(b) boundsList[[b]])

          # now that the bounds list is in the same order as the trade df, we
          # can start updating the values in the boundaries using the indicies
          # (ie row number in the trades df)
          plyr::llply(1:length(boundsList), function(i){
            # make sure this is a boundary that "should" be updated; leave the
            # upstream model bounds alone for now; we can certainly use a time
            # series of values to change these later, but for now hold them
            # constant...
            if(!boundsList[[i]]$usModBound){

              # if we're working with a water trade, then...
              if(boundsList[[i]]$currency == "H2O" & boundsList[[i]]$boundarySuperClass == "transport"){
                # update Q
                boundsList[[i]]$discharge <- tradeDf$tradeVals[i] / timeInterval # Pay attention: Units matter here; this is L s-1 in the current model
                # update everything that depends on Q
                Boundary$public_methods$populateDependencies(boundsList[[i]])

              }
              if(boundsList[[i]]$currency == "NO3") {
                if(boundsList[[i]]$boundarySuperClass == "transport"){
                  boundsList[[i]]$soluteLoad <- tradeDf$tradeVals[i]

                }
                if(boundsList[[i]]$boundarySuperClass == "reaction"){
                  # placeholder #
                  # do nothing for now #
                }
              } # close nitrate currency
            } # close boundary
          } # close internal function passed to llply
          ) # close llply
        } # close initialize
      ) # close public
  ) # close class
