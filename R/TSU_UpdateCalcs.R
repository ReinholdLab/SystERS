#' @title UpdateCells
#'
#' @description Update water and solute values in each cell.
#'
#' @param cells A list of cells in the model.
#' @param storesList A list of stores values generated by \code{CalcStores$new()}.
#'
#' @return A list of cells with updated water and solute values.
#'

UpdateCells <-
  R6::R6Class(
    classname = "UpdateCells",
    public =
      list(
        cells = NULL,
        initialize =
          function(cells){

            lapply(cells, function(cellToUpdate) {

              cellToUpdate$channelVolume_m3 <- cellToUpdate$channelVolume_L / 1000
              cellToUpdate$channelDepth <- cellToUpdate$channelVolume_m3 / cellToUpdate$channelArea # assumes channel is a rectangular cuboid with fixed W and L

              #### Need to figure out how we want to calculate discharge so that
              #### we can update mean water velocity, channel residence time,
              #### and hydraulic load ###

              cellToUpdate$soluteConcentration <- cellToUpdate$soluteMass / cellToUpdate$channelVolume_L
            }
            )
            return()
          }
      )

  )

#' @title UpdateBounds
#'
#' @description Update boundaries based on trades.
#'
#' @param tradeDf A dataframe of trades.  This is generated by the WQModel$trade
#'   method; currently, it is the first object returned in the list.
#' @param boundsList A list containing all the boundaries in the model.
#' @param timeInterval The duration of the time step.
#'
#' @return A list of boundaries with updated values.
#'

UpdateBounds <-
  R6::R6Class(
    classname = "UpdateBounds",
    public =
      list(
        cells = NULL,
        initialize = function(tradeDf, timeInterval){

          boundsList <- lapply(tradeDf$trades, function(t) t$boundary)
          currencyList <- lapply(boundsList, '[[', "currency")
          boundSuperClassList <- lapply(boundsList, '[[', "boundarySuperClass")
          tradeList <- tradeDf$trades


         # the bounds list is in the same order as the trade list, so we
          # can start updating the values in the boundaries using the trade values
          plyr::llply(1:length(boundsList), function(i){
            # make sure this is a boundary that "should" be updated; leave the
            # upstream model bounds alone for now; we can certainly use a time
            # series of values to change these later, but for now hold them
            # constant...
            if(!boundsList[[i]]$usModBound){

              # if we're working with a water trade, then...
              if(currencyList[[i]] == "H2O" & boundSuperClassList[[i]] == "transport"){
                # update Q
                boundsList[[i]]$discharge <- tradeList[[i]]$volumeToTrade / timeInterval # Pay attention: Units matter here; this is L s-1 in the current model
                # update everything that depends on Q
                Boundary$public_methods$populateDependencies(boundsList[[i]])
              }
              if(currencyList[[i]] == "NO3") {
                if(boundSuperClassList[[i]] == "transport"){
                  boundsList[[i]]$soluteLoad <- tradeList[[i]]$soluteToTrade
                }
                if(boundSuperClassList[[i]] == "reaction"){
                  # placeholder #
                  # do nothing for now #
                }
              } # close nitrate currency
            } # close boundary
          } # close internal function passed to llply
          ) # close llply
          return()
        } # close initialize
      ) # close public
  ) # close class
